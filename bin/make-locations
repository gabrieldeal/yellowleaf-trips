#-*-perl-*-

# For example data, see data\gabrielx\templates\winter

use strict;
use lib './lib';

use Carp ();
use Data::Dumper ();
use Scramble::Misc ();
use Scramble::Logger ();
use Date::Manip ();
use File::Find ();
use File::Path ();
use Getopt::Long ();
use IO::File ();

local $^W = 1;
local $| = 1;
local $SIG{__WARN__} = sub { Carp::confess "DIEING on warning: @_" };
local $SIG{__DIE__}  = sub { Carp::confess "DIEING: @_" };

my @g_options = qw(
                   output-directory=s
                   help
                   verbose
		   );
my %g_options = (
                 "output-directory" => "data/locations",
                 verbose => 0,
		 );

exit(main());

###

sub usage {
    my ($prog) = ($0 =~ /([^\/]+)$/);
    sprintf("Usage: $prog [ OPTIONS ]\nOptions:\n\t--"
	    . join("\n\t--", @g_options)
            . <<EOT);

EOT
}

sub get_options {
    local $SIG{__WARN__};
    if (! Getopt::Long::GetOptions(\%g_options, @g_options)
	|| $g_options{'help'})
    {
	print usage();
        exit 1;
    }

    foreach my $required (qw(
                             output-directory
                            ))
    {
	die "Missing --$required" unless exists $g_options{$required};
        if ($g_options{$required} =~ m,^/, || $g_options{$required} =~ m,\.\.,) {
            die "--$required must be a relative path and contain no '..'";
        }
    }

    Scramble::Misc::set_output_directory($g_options{'output-directory'});
    Scramble::Logger::set_verbose($g_options{'verbose'});
}

sub add {
    my ($locations, $name, $args) = @_;

    foreach my $key (qw(state book area type name)) {
        die "Missing $key" unless exists $args->{$key};
    }

    foreach my $key (qw(state type name)) {
        if (exists $locations->{$name}{$key} && $locations->{$name}{$key} ne $args->{$key}) {
            die "'$key' mismatch for $name";
        }
        $locations->{$name}{$key} = $args->{$key};
    }

    foreach my $key (qw(area book)) {
        push @{ $locations->{$name}{$key} }, $args->{$key};
    }
}

sub main {
    srand($$ ^ time());
    get_options();

    my %locations;
    my %args;
    while (defined(my $line = <>)) {
        next unless $line =~ /\S/;
        next if $line =~ /^\s*\#/;
        my ($key, $value) = ($line =~ /^(\w+)=(.*)/);
        die "Bad line: $line" unless defined $key;
        $args{$key} = $value;
        if ($key eq 'name') {
            add(\%locations, $value, \%args);
        }
    }

    foreach my $name (keys %locations) {
        print_location($name, %{ $locations{$name} });
    }

    return 0;
}

sub dedup {
    my @v = @_;

    my %h = map { $_ => 1 } @v;

    return sort keys %h;
}

sub print_location {
    my ($name, %args) = @_;

    foreach my $key (qw(type name area state book)) {
        die "Missing '$key'" unless exists $args{$key};
    }

    my $areas;
    foreach my $area (dedup(@{ $args{area} }, $args{state})) {
        $areas .= <<EOT;
<area id="$area"/>
EOT
    }

    my $references;
    foreach my $book (@{ $args{book} }) {
        $references .= <<EOT;
<reference id="$book"/>
EOT
    }

    my $html = <<EOT;
<location
    type="$args{type}"
>

<name value="$args{name}"/>

<areas>
$areas</areas>

<references>
$references</references>

</location>
EOT


    my $filename = $args{name};
    $filename =~ s/\s+/-/g;
    $filename = "data/locations/$filename.xml";
    print "Writing $filename\n";

    if (-e $filename) {
        die "$filename already exists";
    }

    my $fh = new IO::File($filename, 'w');
    $fh or die "Unable to create '$filename'";
    $fh->print($html);
    $fh->close();
}


1;
