#!c:/Perl64/bin/perl
#-*-perl-*-

use strict;
use lib './lib';
use IO::File ();
#use Image::IPTCInfo ();
use Data::Dumper ();
use Image::ExifTool ();

my $SMALL_IMAGE_SIZE = 333;
my $LARGE_IMAGE_SIZE = 1075;

my $dir = shift @ARGV;

if ($ARGV[-1] =~ /fuck-line-feeds/) {
  pop @ARGV;
}

exit(make_xml($dir, @ARGV));

######################################################################

sub make_xml {
    my ($image_dir, $trip_type, $title) = @_;

    defined $title or die "Missing arguments: image-dir trip-type title";
    -d $image_dir or die "Non-existant image dir: $image_dir";

    my ($data_dir, $image_subdir) = ($image_dir =~ m{^(.*)/images/+([^/]+)/*$});
    defined $image_subdir or die "Bad images dir: $image_dir";

    my ($date) = ($image_subdir =~ /^(\d{4}-\d\d-\d\d)/);
    defined $date or die "Unable to get date from image subdirectory: $image_subdir";

    my %image_data = process_images($image_dir, $date);
    my $image_xml_file = "$image_dir/images.xml";
    if (-e $image_xml_file) {
      print "$image_xml_file already exists\n";
    } else {
      write_file($image_xml_file, $image_data{xml});
    }

    my $report_xml = make_report_xml($date, $title, $trip_type, \%image_data);
    my $report_xml_file = "$data_dir/reports/$image_subdir.xml";
    if (-e $report_xml_file) {
      print "$report_xml_file already exists\n";
    } else {
      write_file($report_xml_file, $report_xml);
    }

    chmod(0744, glob("$image_dir/*")) || die "Failed to chmod: $!";

    return 0;
}

sub make_report_xml {
    my ($date, $title, $type, $image_data) = @_;

    my $start = $image_data->{first_timestamp} || '';
    my $end = $image_data->{last_timestamp} || '';
    return <<EOT;
<trip
    start-date="$date"
    name="$title"
    type="$type"
    display-mode="spare"
    trip-id="1"
>

<references />

<locations>
<location name="" quad="" />
</locations>

<party size="1">
<member name="Gabriel Deal" type="author"/>
</party>

<!--

<waypoints>
<waypoint type="ascending"
       location=""
       time="$start"
       elevation=""
/>
<waypoint type="break"
       location=""
       time="$end"
       elevation=""
/>
</waypoints>

-->

</trip>
EOT
}

sub process_images {
    my ($dir, $date) = @_;

    my $xml = <<EOT;
<images date="$date"
        in-chronological-order="true"
        trip-id="1"
>
EOT

    -d $dir or die "No such directory '$dir'";
    my @filenames = glob "$dir/*.gpx";
    push @filenames, glob "$dir/*-enl\.{jpg,png}";
    @filenames = sort @filenames;
    die "No images found in $dir" unless @filenames;

    my @files;
    foreach my $enl_filename (@filenames) {
	$enl_filename =~ s,.*/,,;

	my ($type, $caption, $rating, $timestamp);
	if ($enl_filename =~ /\.gpx$/i) {
	    $type = "gps";
	} elsif ($enl_filename =~ /\broute\b/ or $enl_filename =~ /\bmap\b/) {
	    $type = "map" ;
	} else {
	    my ($orig_filename) = ($enl_filename =~ /^\d+-(\d+)-enl.jpg$/) or die "Failed to parsse '$enl_filename'";
	    my $metadata = get_image_metadata("$dir/$orig_filename.dng");

	    $type = "picture";
	    $rating = get_rating($metadata->{rating}, $enl_filename);
	    $caption = $metadata->{'caption'} || '';
	    $timestamp = $metadata->{'timestamp'};
	}

	my $thumb_filename = $enl_filename;
	if ($type ne 'gps') {
	    $thumb_filename =~ s/-enl\././ or die "$enl_filename, $type";
	}

        push @files, {
	    thumb_filename => $thumb_filename,
	    enl_filename => $enl_filename,
	    type => $type,
	    caption => $caption,
	    rating => $rating,
            timestamp => $timestamp,
        };
    }

    my ($first_timestamp, $last_timestamp);
    foreach my $file (@files) {
        $last_timestamp = $file->{timestamp};
        if (! defined $first_timestamp) {
            $first_timestamp = $file->{timestamp};
        }

	print "$file->{thumb_filename}:\n";

	if ($file->{type} ne 'gps') {
	  make_resized_images($dir, $file);
	}

	$xml .= <<EOT;
<image filename="$file->{thumb_filename}"
       enlarged-filename="$file->{enl_filename}"
        description="$file->{caption}"
	rating3="$file->{rating}"
	type="$file->{type}"
	photographer="Gabriel Deal"
        capture-timestamp="$file->{timestamp}"
/>
EOT
    }
    $xml .= "</images>\n";

    return (xml => $xml,
	    first_timestamp => $first_timestamp,
	    last_timestamp => $last_timestamp);
}

sub get_rating {
  my ($rating, $file) = @_;

  if (! defined $rating) {
      die "Missing a rating on '$file'";
  } elsif ($rating == 1) {
    return 3;
  } elsif ($rating == 2) {
    return 2;
  } elsif ($rating == 3) {
    return 1;
  } else {
    die "Out-of-bounds rating '$rating'.  Must be 1, 2, or 3.";
  }
}

sub make_resized_images {
  my ($dir, $file) = @_;

  my $thumb_file = $file->{thumb_filename};
  my $enl_file = $file->{enl_filename};

  # This should only be used for route maps:
  if (! -e "$dir/$thumb_file") {
      copy($dir, $enl_file, $thumb_file);
  }

  resize($dir, $thumb_file, $SMALL_IMAGE_SIZE);
  resize($dir, $enl_file, $LARGE_IMAGE_SIZE);
}

sub write_file {
    my ($filename, $content) = @_;

    die "$filename already exists" if -e $filename;

    my $fh = IO::File->new($filename, "w");
    $fh || die "Can't open '$filename': $!";
    $fh->print($content);
    $fh->close() or die "Error writing to '$filename': $!";
}

sub get_image_metadata {
  my ($file) = @_;

  my @tags = qw(ImageDescription Rating DateCreated);
  my $info = Image::ExifTool::ImageInfo($file, \@tags);
  die "Error opening $file: " . $info->{Error} if exists $info->{Error};
  print "Warning opening $file: " . $info->{Warning} if exists $info->{Warning};

  # use Data::Dumper;  print Data::Dumper::Dumper($info);

  my $timestamp = $info->{DateCreated} or die "Missing date in '$file'";
  $timestamp =~ s{^(\d{4}):(\d\d):(\d\d)}{$1/$2/$3};

  my $caption = $info->{'ImageDescription'} || '';
  $caption = '' if $caption eq "OLYMPUS DIGITAL CAMERA";
  $caption =~ s/&/&amp;/g;
  $caption =~ s/"/&quot;/g;

  die "Missing rating in '$file'" unless $info->{Rating} =~ /^\d+$/;

  return {
	  rating => $info->{Rating},
	  timestamp => $timestamp,
	  caption => $caption,
	 };
}

sub get_image_attributes {
  my ($file) = @_;

  my $command = qq(identify -verbose $file);
  my $data = `$command`;

  my ($height, $width) = ($data =~ /^\s*Geometry: (\d+)x(\d+)\+/m);
  die "Unable to get size from command $command" unless defined $width;

  my ($interlacing) = ($data =~ /^\s*Interlace: (\w+)/m);
  die "No interlacing from $command" unless defined $interlacing;

  return { height => $height,
	   width => $width,
	   interlaced => $interlacing ne 'None',
       };
}

sub min { $_[0] < $_[1] ? $_[0] : $_[1] }

sub resize {
    my ($dir, $file, $target_height) = @_;

    my $image_attrs = get_image_attributes("$dir/$file");

    my $resize_pct;
    if ($image_attrs->{width} > $image_attrs->{height}) {
      # Landscape orientation
      $resize_pct = min(100, 100 * $target_height / $image_attrs->{width});
    } else {
      # Portrait orientation
      $resize_pct = min(100, 100 * $target_height / $image_attrs->{height});
    }

    my $delta = 0.1;
    if (abs($resize_pct - 100.0) < $delta) {
	if (! $image_attrs->{interlaced}) {
	    print "\tInterlacing $file\n";
	    my_system("mogrify",
		      "-strip",
		      "-interlace", "Line",
		      "$dir/$file");
	}
	return;
    }

    printf("\tResizing $file to %.2f%%...\n", $resize_pct);
    my_system("mogrify",
	      "-strip",
	      "-interlace", "Line",
	      "-resize", "$resize_pct%",
	      "-unsharp", "2x0.5+0.7+0",
	      "-quality", "80",
	      "$dir/$file") == 0
      or die "Failed to convert $dir/$file";
}

sub copy {
    my ($dir, $src_file, $dest_file) = @_;

    my $dest_path = "$dir/$dest_file";

    print "\tCopying $src_file to $dest_file\n";
    my_system("cp", "$dir/$src_file", "$dest_path") == 0
        or die "Failed to copy $dir/$src_file to $dest_path";
}

sub my_system {
    my (@command) = @_;
    return system @command;
}
