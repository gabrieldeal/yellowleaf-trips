#!c:/Perl64/bin/perl
#-*-perl-*-

use strict;
use lib './lib';
use IO::File ();
#use Image::IPTCInfo ();
use Data::Dumper ();
use Image::ExifTool ();

my $SMALL_IMAGE_SIZE = 333;
my $LARGE_IMAGE_SIZE = 1075;

my $dir = shift @ARGV;

if ($ARGV[-1] =~ /fuck-line-feeds/) {
  pop @ARGV;
}

exit(make_xml($dir, @ARGV));

######################################################################

sub make_xml {
    my ($image_dir, $trip_type, $title) = @_;

    defined $title or die "Missing arguments: image-dir trip-type title";
    -d $image_dir or die "Non-existant image dir: $image_dir";

    my ($data_dir, $image_subdir) = ($image_dir =~ m{^(.*)/images/+([^/]+)/*$});
    defined $image_subdir or die "Bad images dir: $image_dir";

    my ($date) = ($image_subdir =~ /^(\d{4}-\d\d-\d\d)/);
    defined $date or die "Unable to get date from image subdirectory: $image_subdir";

    my %image_data = process_images($image_dir, $date);
    my $image_xml_file = "$image_dir/images.xml";
    if (-e $image_xml_file) {
      print "$image_xml_file already exists\n";
    } else {
      write_file($image_xml_file, $image_data{xml});
    }

    my $report_xml = make_report_xml($date, $title, $trip_type, \%image_data);
    my $report_xml_file = "$data_dir/reports/$image_subdir.xml";
    if (-e $report_xml_file) {
      print "$report_xml_file already exists\n";
    } else {
      write_file($report_xml_file, $report_xml);
    }

    chmod(0744, glob("$image_dir/*")) || die "Failed to chmod: $!";

    return 0;
}

sub make_report_xml {
    my ($date, $title, $type, $image_data) = @_;

    my $start = $image_data->{first_timestamp} || '';
    my $end = $image_data->{last_timestamp} || '';
    return <<EOT;
<trip
    start-date="$date"
    name="$title"
    type="$type"
    display-mode="spare"
    trip-id="1"
>

<references />

<locations>
<location name="" quad="" />
</locations>

<party size="1">
<member name="Gabriel Deal" type="author"/>
</party>

<!--

<waypoints>
<waypoint type="ascending"
       location=""
       time="$start"
       elevation=""
/>
<waypoint type="break"
       location=""
       time="$end"
       elevation=""
/>
</waypoints>

-->

</trip>
EOT
}

sub process_images {
    my ($dir, $date) = @_;

    my $xml = <<EOT;
<images date="$date"
        in-chronological-order="true"
        trip-id="1"
>
EOT

    -d $dir or die "No such directory '$dir'";
    my @filenames = glob "$dir/*-orig\.{JPG,jpg,jpeg,JPEG,png,gif,PNG,GIF,gpx,GPX}";
    @filenames = sort @filenames;
    die "No images found in $dir" unless @filenames;

    my @files;
    foreach my $orig_filename (@filenames) {
	$orig_filename =~ s,.*/,,;
	next if $orig_filename =~ /images.xml$/;
	next if $orig_filename =~ /~$/;

	my $type = "picture";
	$type = "map" if $orig_filename =~ /\broute\b/ or $orig_filename =~ /\bmap\b/;
	$type = "gps" if $orig_filename =~ /\.gpx$/i;

	my $metadata = get_image_metadata("$dir/$orig_filename");

	my $rating = get_rating($metadata->{rating}, $type, $orig_filename);

	my $caption = $metadata->{'caption'} || '';

	my $timestamp = $metadata->{'timestamp'};

	my $thumb_filename = $orig_filename;
	$thumb_filename =~ s/-orig\././ or die "$orig_filename";

	my $enl_filename = $orig_filename;
	$enl_filename =~ s/-orig\./-enl./ or die "$orig_filename";

        push @files, {
	    filename => $orig_filename,
	    thumb_filename => $thumb_filename,
	    enl_filename => $enl_filename,
	    type => $type,
	    caption => $caption,
	    rating => $rating,
            timestamp => $timestamp,
        };
    }

    my ($first_timestamp, $last_timestamp);
    foreach my $file (sort { $a->{timestamp} cmp $b->{timestamp} } @files) {
        $last_timestamp = $file->{timestamp};
        if (! defined $first_timestamp) {
            $first_timestamp = $file->{timestamp};
        }

	if ($file->{type} ne 'gps') {
	  make_resized_images($dir, $file);
	}

	next if $file->{filename} =~ /~$/;
	$xml .= <<EOT;
<image filename="$file->{thumb_filename}"
       enlarged-filename="$file->{enl_filename}"
        description="$file->{caption}"
	rating3="$file->{rating}"
	type="$file->{type}"
	photographer="Gabriel Deal"
        capture-timestamp="$file->{timestamp}"
/>
EOT
    }
    $xml .= "</images>\n";

    return (xml => $xml,
	    first_timestamp => $first_timestamp,
	    last_timestamp => $last_timestamp);
}

sub get_rating {
  my ($rating, $type, $file) = @_;

  return 3 if $type =~ /^(map|gps)$/;

  if (!defined $rating) {
      die "Missing a rating on '$file'";
  } elsif ($rating == 1) {
    return 3;
  } elsif ($rating == 2) {
    return 2;
  } elsif ($rating == 3) {
    return 1;
  } else {
    die "Out-of-bounds rating '$rating'.  Must be 1, 2, or 3.";
  }
}

sub make_resized_images {
  my ($dir, $file) = @_;

  my $orig_file = $file->{filename};
  my $thumb_file = $file->{thumb_filename};
  my $enl_file = $file->{enl_filename};

  if (! should_copy($dir, $orig_file, $enl_file)) {
      warn "Not copying to $enl_file, it already exists and $orig_file has not changes since $enl_file was created\n";
      return undef;
  }

  copy($dir, $orig_file, $enl_file);
  copy($dir, $orig_file, $thumb_file);

  resize($dir, $thumb_file, $SMALL_IMAGE_SIZE);
  resize($dir, $enl_file, $LARGE_IMAGE_SIZE);
}

sub write_file {
    my ($filename, $content) = @_;

    die "$filename already exists" if -e $filename;

    my $fh = IO::File->new($filename, "w");
    $fh || die "Can't open '$filename': $!";
    $fh->print($content);
    $fh->close() or die "Error writing to '$filename': $!";
}

sub get_image_metadata {
  my ($file) = @_;

  return undef unless $file =~ /(\.jpg|\.jpeg|\.tiff)$/i;

#   my $info = new Image::IPTCInfo($file);
#   die "Error opening $file: " . Image::IPTCInfo::Error() unless defined($info);
#   my $capture_date = $info->Attribute('date created');
#   $capture_date =~ s{^(\d{4})(\d\d)(\d\d)}{$1/$2/$3};

#   my $capture_time = $info->Attribute('time created');
#   $capture_time =~ s{^(\d{2})(\d\d)(\d\d)}{$1:$2:$3};

#
#   print Data::Dumper::Dumper($info);
# exit(0);


# use Image::MetaData::JPEG;
#   my $image = Image::MetaData::JPEG->new($file);
#   die 'Error: ' . Image::MetaData::JPEG::Error() unless $image;
# print $image->get_description();

#   my @segments = $image->get_segments('APP');
# printf "Got %d segments from $file\n", scalar(@segments);
#   foreach my $segment (@segments) {
#     my $records = $segment->{records};
#     printf '%s has %d records\n', $segment->{name}, scalar @$records;
#     foreach my $record (@$records) {
#       printf("   Record name '%s' type %s: %s\n",
# 	     $record->{key},
# 	     $record->{type},
# 	    $record->get_description());
#     }
# print "Segment " . $segment->{name} . "\n";
#     my $hash_ref = $segment->get_app13_data('TEXTUAL', 'IPTC');
#     while (my ($key, $vals) = each %$hash_ref) {
#       printf "# %20s =", $key; print " '$_'" for @$vals; print "\n"; }
#   }
#exit(0);

  my @tags = qw(Caption-Abstract Rating DateTimeCreated);
  my $info = Image::ExifTool::ImageInfo($file, \@tags);
  die "Error opening $file: " . $info->{Error} if exists $info->{Error};
  print "Warning opening $file: " . $info->{Warning} if exists $info->{Warning};

  my $timestamp = $info->{DateTimeCreated};
  $timestamp =~ s{^(\d{4}):(\d\d):(\d\d)}{$1/$2/$3};

  my $caption = $info->{'Caption-Abstract'} || '';
  $caption = '' if $caption eq "OLYMPUS DIGITAL CAMERA";
  $caption =~ s/&/&amp;/g;
  $caption =~ s/"/&quot;/g;

  return {
	  rating => $info->{Rating},
	  timestamp => $timestamp,
	  caption => $caption,
	 };
}

sub get_dimensions {
  my ($file) = @_;

  my $command = qq(identify -format "%w %h" $file);
  my $dimension_str = `$command`;
  my ($height, $width) = ($dimension_str =~ /^(\d+) (\d+)$/);
  die "Unable to get size from command $command" unless defined $width;
  return ($height, $width);
}

sub min { $_[0] < $_[1] ? $_[0] : $_[1] }

sub resize {
    my ($dir, $file, $target_height) = @_;

    my ($height, $width) = get_dimensions("$dir/$file");

    my $resize_pct;
    if ($width > $height) {
      # Landscape orientation
      $resize_pct = min(100, 100 * $target_height / $width);
    } else {
      # Portrait orientation
      $resize_pct = min(100, 100 * $target_height / $height);
    }

    printf("Resizing $file to %.2f%%...\n", $resize_pct);
    my_system("mogrify",
	      "-strip",
	      "-interlace", "Line",
	      "-resize", "$resize_pct%",
	      "-unsharp", "2x0.5+0.7+0",
	      "-quality", "80",
	      "$dir/$file") == 0
      or die "Failed to convert $dir/$file";
}

sub should_copy {
    my ($dir, $src_file, $dest_file) = @_;

    return 1 unless -e "$dir/$dest_file";

    my $src_file_mtime = (stat("$dir/$src_file"))[9];
    my $dest_file_mtime = (stat("$dir/$dest_file"))[9];
    return $src_file_mtime > $dest_file_mtime;
}

sub copy {
    my ($dir, $src_file, $dest_file) = @_;

    my $dest_path = "$dir/$dest_file";

    my_system("cp", "$dir/$src_file", "$dest_path") == 0
        or die "Failed to copy $dir/$src_file to $dest_path";
}

sub my_system {
    my (@command) = @_;
    return system @command;
}
