#!c:/Perl64/bin/perl
#-*-perl-*-

use strict;
use lib './lib';
use IO::File ();
#use Image::IPTCInfo ();
use Data::Dumper ();
use Image::ExifTool ();
use File::Spec ();
use Scramble::Area ();
use Scramble::Location ();
use XML::Generator ();

my $SMALL_IMAGE_SIZE = 333;
my $LARGE_IMAGE_SIZE = 1075;

my $dir = shift @ARGV;

if ($ARGV[-1] =~ /fuck-line-feeds/) {
  pop @ARGV;
}

my $xg = XML::Generator->new(escape => 'always',
                             conformance => 'strict',
                             pretty => 4);


exit(make_xml($dir, @ARGV));

######################################################################

sub make_xml {
    my ($image_dir, $trip_type, $title) = @_;

    defined $title or die "Missing arguments: image-dir trip-type title";
    -d $image_dir or die "Non-existant image dir: $image_dir";

    my ($data_dir, $image_subdir) = ($image_dir =~ m{^(.*)/reports/+([^/]+)/*$});
    defined $image_subdir or die "Bad images dir: $image_dir";

    my ($date) = ($image_subdir =~ /^(\d{4}-\d\d-\d\d)/);
    defined $date or die "Unable to get date from image subdirectory: $image_subdir";

    my @locations = prompt_for_locations();

    my %image_data = process_images($image_dir);

    my $report_xml_file = "$data_dir/reports/$image_subdir/report.xml";
    if (-e $report_xml_file) {
      print "$report_xml_file already exists\n";
    } else {
        my $report_xml = make_report_xml(date => $date,
                                         title => $title,
                                         trip_type => $trip_type,
                                         locations => \@locations,
                                         image_data => \%image_data,
                                         image_subdir => $image_subdir);
        write_file($report_xml_file, $report_xml);
    }

    # geotag($image_data{files});

    chmod(0744, glob("$image_dir/*")) || die "Failed to chmod: $!";

    return 0;
}

sub prompt_for_locations {
    my @locations;

    my $prompt = "Location (^D to quit): ";
    print $prompt;
    Scramble::Area::open();
    while (my $location_name = <STDIN>) {
        my @location_matches;
        my $location_regex = "\Q". join('\E.*\Q', split(/\s+/, $location_name)) . "\E";
        foreach my $location_filename (glob("$Scramble::Location::DIRECTORY/*.xml")) {
            if ($location_filename =~ /$location_regex/i) {
                push @location_matches, Scramble::Location::open_specific($location_filename);
            }

        }

        my @location_choices = map {
            { name => sprintf("%s (%s)", $_->get_name(), ($_->get_quad_objects())[0]{name}),
              value => $_
            }
        } @location_matches;
        my $location = Scramble::Misc::choose_interactive(@location_choices);

        push @locations, $location if $location;

        print $prompt;
    }

    return @locations;
}

sub validate_arguments {
    my ($image_dir, $trip_type, $title) = @_;

    defined $title or die "Missing arguments: image-dir trip-type title";
    -d $image_dir or die "Non-existant image dir: $image_dir";

    my ($data_dir, $image_subdir) = ($image_dir =~ m{^(.*)/reports/+([^/]+)/*$});
    defined $image_subdir or die "Bad images dir: $image_dir";

    my ($date) = ($image_subdir =~ /^(\d{4}-\d\d-\d\d)/);
    defined $date or die "Unable to get date from image subdirectory: $image_subdir";
}

sub geotag {
    my ($files) = @_;

    my @gpx_files = grep { $_->{type} eq 'gps'} @$files;
    return unless @gpx_files;
    die "Too many GPX files: @gpx_files" unless @gpx_files == 1;
    my $gpx_file = "$gpx_files[0]{dir}/$gpx_files[0]{enl_filename}";

    my @image_files = grep { $_->{type} eq 'picture' } @$files;
    return unless @image_files;
    my @image_filenames = map { ("$gpx_files[0]{dir}/$_->{thumb_filename}", "$gpx_files[0]{dir}/$_->{enl_filename}") } @image_files;

    # For example, the following command compensates for image times which
    # are 1 minute and 20 seconds behind GPS:
    # exiftool -geosync=+1:20 -geotag a.log DIR
    warn "Is camera and GPS synced????";
    my @command = ('exiftool',
		   '-verbose',
		   '-geotag', $gpx_file,
		   @image_filenames);
    my_system(@command);
}

sub make_locations_xml {
    my ($locations) = @_;

    my @location_attrs = map {
        {
            name => $_->get_name(),
            quad => ($_->get_quad_objects())[0]->get_id(),
        }
    } @$locations;

    return $xg->locations(map { $xg->location($_) } @location_attrs);
}

sub make_report_xml {
    my %args = @_;

    $args{title} =~ s/&/&amp;/g; # It is still the dark ages here.

    my $files_xml = make_files_xml($args{image_data}{files}, $args{date});
    my $locations_xml = make_locations_xml($args{locations});

    my $start = $args{image_data}{first_timestamp} || '';
    my $end = $args{image_data}{last_timestamp} || '';
    return <<EOT;
<trip filename="$args{image_subdir}"
    start-date="$args{date}"
    name="$args{title}"
    type="$args{trip_type}"
    trip-id="1"
>

<description />

<references />

$locations_xml

<party size="1">
<member name="Gabriel Deal" type="author"/>
</party>

<round-trip-distances>
    <distance type="foot" miles=""/>
    <distance type="bike" miles=""/>
</round-trip-distances>


<waypoints elevation-gain="">
<waypoint type="ascending"
       location-description=""
       time="$start"
       elevation=""
/>
<waypoint type="break"
       location-description=""
       time="$end"
       elevation=""
/>
</waypoints>

$files_xml

</trip>
EOT
}

sub prompt_yes_or_no {
    my ($prompt) = @_;
    while (1) {
        print "$prompt\ny/n (y)? ";
        my $answer = <STDIN>;
        chomp $answer;
        return 1 if lc($answer) eq 'y' || $answer eq '';
        return 0 if lc($answer) eq 'n';
    }
}

sub make_files_xml {
    my ($files, $date) = @_;

    my @file_xmls;
    foreach my $file (@$files) {
        my %optional_attrs;
        if ($file->{caption} =~ /^(.+)\s+(from|over)\s+(.+)/) {
            my ($of, $term, $from) = ($1, $2, $3);
            $from = '' if $term eq 'over';
            my $question = "\n$file->{caption}\nSet the 'of' and 'from' attributes to the below? ('n' sets it to nothing)\nof: $of\nfrom: $from";
            @optional_attrs{'of', 'from'} = prompt_yes_or_no($question) ? ($of, $from) : ('', '');
        }

        push @file_xmls, $xg->file({ %optional_attrs,
                                     'description' => $file->{caption},
                                     'thumbnail-filename' => $file->{thumb_filename},
                                     'large-filename' => $file->{enl_filename},
                                      rating => $file->{rating},
                                      type => $file->{type},
                                      owner => "Gabriel Deal",
                                      'capture-timestamp' => $file->{timestamp},
                                   });
    }
    return $xg->files({ date => $date,
                        'in-chronological-order' => "true",
                        'trip-id' => 1,
                      },
                      @file_xmls);
}

sub make_kml {
    my ($output_dir, @gpx_paths) = @_;

    # gpsconvert chokes on cygwin-style paths.
    my $kml_path = File::Spec->abs2rel("$output_dir/route.kml");
    return if -e $kml_path;

    my @gpx_args;
    foreach my $gpx_path (@gpx_paths) {
        push @gpx_args, ('-i', File::Spec->abs2rel($gpx_path));
    }

    my_system('gpsconvert',
              '--no-waypoints',
              @gpx_args,
              '-o', $kml_path);
}

sub process_images {
    my ($dir) = @_;

    -d $dir or die "No such directory '$dir'";
    $dir =~ s{/*$}{};
    my @gpx_filenames = sort(glob "$dir/*.gpx");
    make_kml($dir, @gpx_filenames) if @gpx_filenames;

    my @filenames = @gpx_filenames;
    push @filenames, glob "$dir/*.kml";
    push @filenames, glob "$dir/*-enl\.{jpg,png}";
    @filenames = sort @filenames;

    my @files;
    foreach my $enl_filename (@filenames) {
	$enl_filename =~ s,.*/,,;

	my ($type, $caption, $rating, $timestamp);
	if ($enl_filename =~ /\.(gpx)$/i) {
	    $type = "gps";
        } elsif ($enl_filename =~ /\.(kml)$/i) {
	    $type = "kml";
	} elsif ($enl_filename =~ /\broute\b/ or $enl_filename =~ /\bmap\b/) {
	    $type = "map" ;
	} else {
            my ($orig_filename) = ($enl_filename =~ /^\d+-([-\w_\(\)]+)-enl.jpg$/) or die "Failed to parse '$enl_filename'";
            my $orig_filename_glob = "$dir/$orig_filename.*";
            my @orig_filenames = glob($orig_filename_glob);
            @orig_filenames == 1 or die(sprintf("Got %s matches for '$orig_filename_glob': @orig_filenames", scalar(@orig_filenames)));
	    
	    my $metadata = get_image_metadata("$orig_filenames[0]");
	    die "Unable to find rating in $orig_filenames[0]" unless defined $metadata->{rating};

	    $type = "picture";
	    $rating = get_rating($metadata->{rating});
	    $caption = $metadata->{'caption'} || '';
	    $timestamp = $metadata->{'timestamp'};
	}

	my $thumb_filename = $enl_filename;
	if ($type ne 'gps' && $type ne 'kml') {
	    $thumb_filename =~ s/-enl\././ or die "$enl_filename, $type";
	}

        push @files, {
	    dir => $dir,
	    thumb_filename => $thumb_filename,
	    enl_filename => $enl_filename,
	    type => $type,
	    caption => $caption,
	    rating => $rating,
            timestamp => $timestamp,
        };
    }

    my (@file_xmls, $first_timestamp, $last_timestamp);
    foreach my $file (@files) {
	print "$file->{thumb_filename}:\n";

	if ($file->{type} ne 'gps' && $file->{type} ne 'kml') {
  	    make_resized_images($dir, $file);

	    $last_timestamp = $file->{timestamp};
	    if (! defined $first_timestamp) {
		$first_timestamp = $file->{timestamp};
	    }
	}

    }

    return (files => \@files,
	    first_timestamp => $first_timestamp,
	    last_timestamp => $last_timestamp);
}

sub get_rating {
  my ($rating) = @_;

  if (! defined $rating) {
      die "Missing rating";
  } elsif ($rating == 1) {
    return 3;
  } elsif ($rating == 2) {
    return 2;
  } elsif ($rating == 3) {
    return 1;
  } else {
    die "Out-of-bounds rating '$rating'.  Must be 1, 2, or 3.";
  }
}

sub make_resized_images {
  my ($dir, $file) = @_;

  my $thumb_file = $file->{thumb_filename};
  my $enl_file = $file->{enl_filename};

  # This should only be used for route maps:
  if (! -e "$dir/$thumb_file") {
      copy($dir, $enl_file, $thumb_file);
  }

  resize($dir, $thumb_file, $SMALL_IMAGE_SIZE);
  resize($dir, $enl_file, $LARGE_IMAGE_SIZE);
}

sub write_file {
    my ($filename, $content) = @_;

    die "$filename already exists" if -e $filename;

    my $fh = IO::File->new($filename, "w");
    $fh || die "Can't open '$filename': $!";
    $fh->print($content);
    $fh->close() or die "Error writing to '$filename': $!";
}

sub get_image_metadata {
  my ($file) = @_;

  my @tags = qw(ImageDescription Rating DateCreated CreateDate);
  my $info = Image::ExifTool::ImageInfo($file, \@tags);
  die "Error opening $file: " . $info->{Error} if exists $info->{Error};
  print "Warning opening $file: " . $info->{Warning} if exists $info->{Warning};

  my $timestamp = $info->{'DateCreated (1)'} || $info->{DateCreated} || $info->{CreateDate} or warn "Missing date in '$file': " . Data::Dumper::Dumper($info);
  if (defined $timestamp) {
      $timestamp =~ s{^(\d{4}):(\d\d):(\d\d)}{$1/$2/$3};
      $timestamp =~ s/\.\d\d\d$//;
  }

  my $caption = $info->{'ImageDescription'} || '';
  $caption = '' if $caption eq "OLYMPUS DIGITAL CAMERA";
  $caption =~ s/&/&amp;/g;
  $caption =~ s/"/&quot;/g;

  return {
	  rating => $info->{Rating},
	  timestamp => $timestamp,
	  caption => $caption,
	 };
}

sub get_image_attributes {
  my ($file) = @_;

  my $command = qq(identify -verbose "$file");
  my $data = `$command`;

  my ($height, $width) = ($data =~ /^\s*Geometry: (\d+)x(\d+)\+/m);
  die "Unable to get size from command $command" unless defined $width;

  my ($interlacing) = ($data =~ /^\s*Interlace: (\w+)/m);
  die "No interlacing from $command" unless defined $interlacing;

  return { height => $height,
	   width => $width,
	   interlaced => $interlacing ne 'None',
       };
}

sub min { $_[0] < $_[1] ? $_[0] : $_[1] }

sub resize {
    my ($dir, $file, $target_height) = @_;

    my $image_attrs = get_image_attributes("$dir/$file");

    my $resize_pct;
    if ($image_attrs->{width} > $image_attrs->{height}) {
      # Landscape orientation
      $resize_pct = min(100, 100 * $target_height / $image_attrs->{width});
    } else {
      # Portrait orientation
      $resize_pct = min(100, 100 * $target_height / $image_attrs->{height});
    }

    my $delta = 0.1;
    if (abs($resize_pct - 100.0) < $delta) {
	if (! $image_attrs->{interlaced}) {
	    print "\tInterlacing $file\n";
	    my_system("mogrify",
		      #"-strip", breaks geotagging
		      "-interlace", "Line",
		      "$dir/$file");
	}
	return;
    }

    printf("\tResizing $file to %.2f%%...\n", $resize_pct);
    my_system("mogrify",
	      # "-strip", breaks geotagging
	      "-interlace", "Line",
	      "-resize", "$resize_pct%",
	      "-unsharp", "2x0.5+0.7+0",
	      "-quality", "80",
              "$dir/$file");
}

sub copy {
    my ($dir, $src_file, $dest_file) = @_;

    my $dest_path = "$dir/$dest_file";

    print "\tCopying $src_file to $dest_file\n";
    my_system("cp", "$dir/$src_file", "$dest_path");
}

sub my_system {
    my (@command) = @_;
    return if 0 == system @command;

    die "Command exited with failure code ($?): @command";
}
